# -*- coding: utf-8 -*-
#
"""
Author: Tosei Hiratsuka (2020.3.9)

READ manual.txt BEFORE USE.

Input: The file obtained by scoring the nucleotide sequence with a 5UTR score (generated by chrom_scan.py).
Output: The position and value of both ends of the detected peak.

At the command prompt, enter the following.
    python3 peak_find_SG_5UTR_edge_both.py [Scored by 5'UTR score 1] [Scored by 5'UTR score 2]...

For example,
    python3 peak_find_SG_5UTR_edge_both.py Chr1_scan_5UTR-IGI750_450_forward.txt

The peak is filtered by threshold of peak value.


If a file with the same name as the output file already exists, it will be overwritten without warning.
If you want to change the output directory, enter the variable ("save_dir") below.
"""

save_dir = r""
#The directory for saving output files
#If blank, the output file will be in the directory where this script is located.



import os
import sys
import re
import numpy as np 
from scipy import signal
import time

t1=time.time()
#Get start time.

if save_dir == "":
    save_dir = os.path.dirname(os.path.abspath(__file__)) + os.sep
    #Get the absolute path of the directory where this script is located.

N = 151
#Smoothing width (odd number)
D = 1
#Order used for smoothing by SG filter.

th = 0    #The threshold of peak value.

#tougou = 50 #The width for peak integration (bp).

def infoExt(scanFile):
    """
    To extract information from the file scored by chrom_scan.py.
    :param scanFile: The file scored by chrom_scan.py.
    :return: Chromosome number, Direction, Score name.
    """

    with open(scanFile, "rt") as sf:
        for line in sf:
            if re.match("Chromosome", line):
                chrom = re.search("([cC]hr\d+)\D*", line).group(1)
            elif re.match("Score", line):
                scName = re.search("Score:\s(.+)\n", line).group(1)
            elif re.match("Strand", line):
                strand = re.search("Strand:\s(.+)\n", line).group(1)
            elif re.match("\d+", line):
                break
    return chrom, scName, strand

def save_generate(save_directory, chrom, orientation):
    """
    To generate output files (forward and reverse).
    :param save_directory: The directory for saving output files.
    :param chrom: The chromosome number.
    :param orientation: Scoring direction（forward or reverse）
    :return: Name of output files.
    """
    
    saveFile = save_directory + "{}_5UTRedge_both_{}.txt".format(chrom, orientation)
    return saveFile

def saveWrite(save_file, chrom, strand, window, degree, threshold, *arg):
    """
    To write basic information to the output file.
    :param save_file: The output file.
    :param chrom: Chromosome number.
    :param strand: The chain.（forward or reverse）
    :param window: Smoothing width
    :param degree: Order used for smoothing
    :param threshold: The threshold of 5'UTR score for peak detection.
    :param *arg: Others that you want to write to the output file. These are written at the beginning of the file.
    """
    
    with open(save_file, "wt") as save:
        for item in arg:
            print(item, file=save)
        print("\nChromosome:", chrom, file=save)
        print("Score:", score, file=save)
        print("Strand:", strand, file=save)
        print("Window Size:", window, file=save)
        print("Degree:", degree, file=save)
        print("Threshold: {}".format(threshold), file=save)
        print("\nEdge Left", "Edge Right", "Peak Height", sep="\t", file=save)

def scoreExt(scanFile):
    """
    To generate an array of scores from the file scored by chrom_scan.py.
    Also returns the top location.
    :param scanFile: The file scored by chrom_scan.py.
    :return: numpy.ndarray of locations and values.
    """

    start = ""
    score = []
    with open(scanFile, "rt") as sf:
        for line in sf:
            if re.match("\d", line):
                line = line.replace("\n", "").split("\t")
                score.append(float(line[1]))
                if start == "":
                    start = int(line[0])
    score = np.array(score)
    return start, score

def edgeFind(raw_array, threshold, start):
    """
    Apply the SG-filter to the input data.
    Then, detect the position of both ends of the peak and the maximum value of the peak.
    :param raw_array: raw data（numpy.ndarray）
    :param threshold: The threshold of 5'UTR score.
    :param start: Location of the first 5UTR score (return value of scoreExt).
    :return: numpy.ndarray of peak position（both ends） and value.
    """

    sd = signal.savgol_filter(raw_array, N, D)
    #Smoothed data.
    del raw_array
    print('"S-G filter complete"')

    edgeL = []    #To store indexes of the left end of peak.
    edgeR = []    #To store indexes of the right end of peak.
    peaks = []    #To store peak values.
    up = 0        #The start point of peak.
    down = 0      #The end point of peak.
    for i in range(N - 1, sd.size - 1 - (N - 1) + 1):
        #Search for peaks only in indexes with valid smoothing values.
        if sd[i] < 0 and sd[i+1] >= 0:
            up = i
        elif sd[i] >= 0 and sd[i+1] < 0:
            down = i+1
            peak_max = sd[up : down].max()    #The max value of peak.
            if peak_max > threshold:
                peaks.append(peak_max)
                edgeL.append(up)
                edgeR.append(down)
    del sd
    posL = np.array(edgeL) + start    #To convert the index to the position of DNA.
    posR = np.array(edgeR) + start
    return posL, posR, np.array(peaks)


inputs = sys.argv
if len(inputs) < 2:
    print("Input the file which scored the whole chromosome by 5'UTR score as the command line argument.")
    quit()

for f in inputs[1:]:
    print("-"*50)
    print(os.path.basename(f))

    chrom, score, ori = infoExt(f)
    save = save_generate(save_dir, chrom, ori)
    saveWrite(save, chrom, ori, N, D, th, __file__, f)

    start, score = scoreExt(f)
    print('"scoreExt complete"')

    posL, posR, peaks = edgeFind(score, th, start)
    del score
    print('"edgeFind complete"')

    for L, R, peak in zip(posL, posR, peaks):
        with open(save, "at") as s:
            print(L, R, peak, sep="\t", file=s)

print("-"*50)
t2=time.time()
t=t2-t1
if t > 60:
    print('time:'+str(t/60)+'(min)')
else:
    print('time:'+str(t)+'(s)')
#To display the time required for processing.